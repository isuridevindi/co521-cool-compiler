README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should contain the following files:

 Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [cool root]/src/PA2/lextest.cc
 mycoolc         -> [cool root]/PA2/mycoolc
 stringtab.cc    -> [cool root]/PA2/stringtab.cc
 utilities.cc    -> [cool root]/PA2/utilities.cc
 handle_flags.cc -> [cool root]/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[cool root]/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the gmake
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------
________________________

GROUP 04
E/17/058: DEVINDI G.A.I
E/17/190: LIYANAGE S.N
_________________________

	The cool.flex file contains all the necessary rules used to generate 
	the lexical analyzer for the cool programming language. It contains three 
	sections as follows to define the lexical analyzer. Each section is 
	seperated by the %% symbol inside the file.

	1. Definitions: This section contains the following components.

		i.  Headers, global variables and definitions of function prototypes used in the file
		ii. Definitions of start conditions used in the Rules section
			e.g.: Defining the exclusive start condition for comments
			
			```
			%x COMMENT
				
			```
		iii. Definitions of names for regular expressions used to indentify 
		     different tokens.

	2. Rules: This section contains rules to identify the tokens in the input string.
		  The rules can be divided into the following 7 sections.

		i. 	Rules to detect comments and associated errors:
			________________________________________________________________________________
			
			According to the cool manual, there are two types of comments.

			 1. Any character between two dashes and next newline/EOF:
				*Detected using the regex definition for DASHCOM. 
				(lines 84 & 180 in cool.flex)

			 2. Enclosing text in (* ... *):
				*Detected using exlusive start condition COMMENT.
				(lines 143-177 in cool.flex)
				
				*Nested comments of this format are identified with the help of the local 
				variable count.
					** Initially count is set to 0, and when entering the COMMENT state,
					count is increased by one. 
					** If another *) is encountered inside COMMENT state, the count is
					increased by 1 and go to COMMENT condition again.
					** When a *) is encountered inside COMMENT state, the number of
					nested comment count is decreased by 1 if count is greater than 0. 
					If count is 0, that means all the nested comments and comments have
					been closed, therefore, goes to the INITIAL state.

				~line 21 in test.cl is used to test whether nested comments are detected
				correctly and ignored.
	
				*If multiline comments are encountered, the curr_lineno 
				variable is increased by 1. (line 167 in cool.flex)

				*Apart from newlines, everything included within (*... *) 
				are ignored without tokenizing. (line 170 in cool.flex)

				*Two errors associated with comments are detected here.
				1. If a *) is detected without entering the COMMENT state,
				   return an ERROR token with message "Unmatched *)" without
				   tokenizing the characters. (lines 143-146 in cool.flex)

				   ~line 42 in test.cl is used to test whether this error is detected.

				2. If EOF is detected before comment is terminated,
		 		   return an ERROR token with message "EOF in comment" without
				   tokenizing the characters. (lines 157-161 in cool.flex)

				   ~line 461 in test.cl is used to test whether this error is detected.

			________________________________________________________________________________


		ii.	Rules to detect strings and associated errors:

			________________________________________________________________________________

			
			* Strings in cool are enclosed in double quotes "..." 

			* When a " is encountered outside STRING condition,
			the STRING start conditions are checked after storing the address of 
			the string_buf used to store 1025 characters in the string_buf_ptr pointer. 
			(lines 198-204 in cool.flex)

			* When a valid character is encountered,it is stored in the address 
			directed by the string_buf_ptr and the pointer is increased by one 
			after checking whether the string length is below the maximum 
			length allowed (1025). Two helper functions namely isLong() and
			maxlen_error() are used to validate the length and return the ERROR token
			if maximum length is exceeded. (eg: Lines 239-241 in cool.flex) 

			* If a " is encountered while in STRING condition, this indicates the 
			end of the string. After checking whether the string length is within the
			limit, the string in the string_buf is added to the stringtable and 
			STR_CONST token is returned and characters stored in buffer pointer are
			cleared by writing '\0'.(lines 220-233 in cool.flex)

			* Since escaped newline characters are valid within strings, a rule is 
			written to capture them and increase the curr_lineno variable. 
			(lines 237-245 in cool.flex)

			* Since the sequence '\c' denotes any character 'c' except \n,\b,\t,\f, a rule 
			is written to capture such characters. (lines 248-255 in cool.flex)

			* A set of rules are written in STRING state to capture the escape sequences 
			\n,\b,\t, and \f and store their ASCII representation in String table.
			(lines 289-326 in cool.flex)

			*Four errors associated with strings are detected here.

			1. EOF in string constant: If EOF is detected before string termination, return
			                           ERROR token with message "EOF in string constant" and
						   go to the INITIAL state.
						   (lines 208-212 in cool.flex)

			2. Unterminated string contant: If an unescaped newline character is detected,
						   return ERROR token with message "Unterminated 
						   string contant" and go to INITIAL state to resume lexing
						   at the next line. (lines 261-266 in cool.flex)
					
					~line 287 in test.cl is used to test whether this error is detected.

			3. String contains null character: If a null character (\0) is encountered inside
						   string, return ERROR token with message "String contains 
						   null character" and go to INVALID_STRING state to avoid 
					           tokenizing the rest of the string.(lines 274-278 in cool.flex)

					~line 390 in test.cl is used to test whether this error is detected.

			4. String constant too long: Before updating the string buffer, the length of the
						   string stored is checked using isLong() function, and if 
						   the length exceeds maximum value, return ERROR token with 
						   message "String constant too long" and go to INVALID_STRING
						   state to avoid tokenizing the rest of the string.
						   
					~line 356 in test.cl is used to test whether this error is detected.

			
			* The exclusive start condition INVALID_STRING is used to avoid tokenizing an invalid 
			string. Once an error is detected in the string, the rules specified in this condition
			are activated and executed until the end of string is detected. 
			(lines 348-363 in cool.flex)

			* Any character that doesn't belong to any of the above rules are valid characters 
			in a string. Therefore, the longest matching token given by yytext is stored 
			in the buffer difrectly. (lines 330-337 in cool.flex)
			________________________________________________________________________________


		iii. 	Rules to detect character operators:
																							
			_______________________________________________________________________________
				
			Multiple character operators such as => , <= , <- and other character operators 
			such as ".","@","~",etc. are detected from the rules specified here and the ASCII
			value of these operators are returned.
			(lines 373-391 in cool.flex)
			________________________________________________________________________________


		iv.	Rules to detect Integers:
			________________________________________________________________________________

			Non empty strings of digits 0-9 are detected here and stored in the inttable and 
			returned with the token INT_CONST.
			(lines 400-403 in cool.flex)
			________________________________________________________________________________



		v. 	Rules to detect keywords:
			________________________________________________________________________________
			
			Case insensitive keywords such as Class,else,if,fi, etc as well as case insensitive 
			keywords flase and true are detected with the rules specified here.
			(lines 412-441 in cool.flex)
			
			________________________________________________________________________________



		vi.	Rules to detect Identifiers:
			________________________________________________________________________________

			Object and type identifiers are detected and stored in the idtable and returned 
			along with the tokens OBJECTID or TYPEID.
			(lines 450-465 in cool.flex)
			________________________________________________________________________________



		vii. 	Other rules:
			________________________________________________________________________________

			* If a newline is detected, that doesn't belong to anyof the above rules, increase
			 curr_lineno variable by 1. (line 470 of cool.flex)

			* If whitespaces (tabs and spaces) are detected,that doesn't belong to anyof 
			the above rules, ignore them. (line 473 of cool.flex)

			* If any character except newline, that doesn't belong to any of the above rules are
			detected, they are invalid tokens. Return ERROR token with the token detected.
			(line 478-482 in cool.flex)
				~line 231 in test.cl is used to test whether this error is detected.
			
			________________________________________________________________________________


	3. User code: This section contains the companion routines called by the rules 
		      associated with STRING token detection in the scanner. 
		      Two functions are defined as follows.
			
			1. bool isLong() -> check the length of the string stored in buffer and return true
					   if the length exceeds the maximum value.

			2. int maxlen_error() -> return the ERROR token with the message "String constant too 
					    long", when the string length exceeds maximum and return to the 
					    INVALID_STRING start condition.
	
	Apart from the test cases specified in the above sections, the test.cl file contains all the valid tokens 
	of the cool program in different formats. 
	
	The validity of our lexer was tested by comparing the outputs generated for the same test.cl file,
	by our lexer and the reference lexer of the cool compiler provided in the folder cool/bin.

--------------------------
END OF WRITE-UP FOR PA2
