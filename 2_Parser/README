README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c       -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  	  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------

_________________________________

GROUP 04
DEVINDI G.A.I	: E/17/058
LIYANAGE S.N 	: E/17/190	
_________________________________


The Bison grammar file cool.y contains the Context-Free Grammar specification
for the Cool language.

The file contains four main sections as shown below.
	
	%{
	   Prologue
	%}

	Bison declarations

	%%
	Grammar rules
	%%
	
	Epilogue

1. Prologue:
	The macros, variables and function definitions are included here.
	The header files, variable to track the line numbers and function prototype
	for the yyerror() function are declared here.

2. Bison declarations:
	Contains declarations that define terminal and nonterminal symbols and precedence
	specifications.
	
	i. 	Data types of the symantic values -> %union

		* To use more than one data type in the parser, the entire collection of
		possible data types are defined using the %union Bison declaraion.
		
		(lines 98 to 113 )
		* Below are the data types defined here.

		      Boolean boolean;
		      Symbol symbol;
		      Program program;
		      Class_ class_;
		      Classes classes;
		      Feature feature;
		      Features features;
		      Formal formal;
		      Formals formals;
		      Case case_;
		      Cases cases;
		      Expression expression;
		      Expressions expressions;
		      char *error_msg;

	ii. 	Terminal symbols declarations-> %token

		*The terminal symbols used in the language are defined using %token.
		*Even though Bison converts the definitions to numeric code, to
		prevent version parity problems, the numeric codes are defined along
		with the name that represents the code.

		(lines 126 to 132 )

		*Below are the terminals declared using %token

			*CLASS 258   	*ELSE 259    *FI 260   	 *IF 261	* IN 262 
    			*INHERITS 263 	*LET 264     *LOOP 265 	 *POOL 266 	*THEN 267 
			*WHILE 268	*CASE 269    *ESAC 270 	 *OF 271 	*DARROW 272
			*NEW 273 	*ISVOID 274  *STR_CONST 275 		*INT_CONST 276 
			*BOOL_CONST 277 *TYPEID 278  *OBJECTID 279 		*ASSIGN 280 
			*NOT 281 	*LE 282      *ERROR 283

		* The single character literal tokens such as '+' and '*' are not declared
		here since they do not have to be declared explicitly.

	iii.	Nonterminal symbols declarations -> %type

		*Since %union declared all possible data type values, the specific value type of 
		each nonterminal symbol are declared here.
		(lines 147 to 164 )

		*The nonterminals are defined to avoid ambiguity and shift-reduce and reduce-reduce
		confilcts in the parser. Below are the nonterminals and their types specified.
		
		   * <program> program 		: Specifying the complete program
		   * <classes> class_list 	: Specifying a collection of classes
		   * <class_> class 		: Specifying a single class
		   * <features> feature_list	: Specifying a list of features
		   * <feature> feature		: Specifying a feature
		   * <formals> formal_list	: Specifying a list of formal parameters
		   * <formal> formal		: Specifying a formal parameter
		   * <expressions> expr_block 	: Represent a block of expressions separated by ; -> [[expr;]]+
		   * <expressions> expr_list 	: Represent a list of expressions separated by ,  -> expr [[ ,expr]]*
 		   * <expression> expr		: Represent an expression	
 		   * <expression> let_expr	: Represent an expression with let construct
 		   * <expression> dispatch_expr	: Represent a dispatch expressions of the form
						  expr[@TYPEID].OBJECTID(expr [[,expr]]*]) and ID *[expr [[,expr]]*)
 		   * <expression> case_expr	: Represent a case expression -> case-of-esac
	           * <cases> case_branches      : Represent a set of case branches -> [[ ID:TYPE => expr;]]*
		   * <case_> case_branch	: Represent a single case branch -> ID:TYPE => expr;

	iv. 	Precedence declarations -> %left, %right and %precedence
		

		*Since all binary operators (except assignment) in Cool language are left associative,
		it's defined using %left. (lines 169 to lines 179 )
			* Declarations at the top have lower precedence than the ones at the bottom.
			* Below are the operators that are defined with %left
				    %left NOT
				    %left '+' '-'
				    %left '*' '/'
				    %left ISVOID
				    %left '~'
				    %left '.' '@'
				    %left '('

		*Since assignment in Cool language is right associative,it's defined using %right.
		(line 169 ) 
		
		*Since the three comparison operators <= , < ,and = are not assosiative , they are
		defined by %nonassoc. (line 171 )

		* %precedence is used to avoid shift-reduce conflicts occurring from the ambiguity
		introduced by the let constrcut. (line 179 )
	
3. Grammar rules:
	*The Bison grammar rules used to develop the abstract-syntax-tree is defined here.
	*The general format of a rule is:
		result : components...;
		where,
		 result = Nonterminal decribed by the rule
		 components = set of terminals and nonterminals that forms the production
		
		* Some components contain actions that determine the semantics of the components
		matched by the rule and are defined as C statements inside curly braces.
			* The semantic value of the grouping being constructed is defined by $$.
			* The semantic value of the nth component is defined by $n.

	* Rules are written to specify the prodcutions for the nonterminals as given in 
	figure 1 of the cool-manual.

	* Since the start symbol should be program, the rules specifying the program are written first
	and assign it as the rool of the AST.
	(line 197 to line 201 )

	* The rules are specified for all the nonterminals defined in the Bison declaration section using %type
	in a manner to avoid shift-reduce and reduce-reduce conficts.
	(line 197 to line 496 )

		Non-terminal	Grammer rule		example in good.cl		
		* program		line 197 - 201		
		* classes		line 205 - 221		line 44, 109, 406 
		* class_		line 228 - 248 		line 44
		* feature		line 272 - 288		line 50 - 52 
		* features		line 254 - 226		line 46 - 48
		* formal		line 313 - 315		line 46
		* formals		line 295 - 307		line 131
		* expression	line 321 - 389		line 129
		* expressions	line 394 - 406		line 150
		* case_			line 460 - 463		line 125
		* cases			line 446 - 454		line 125 - 126
		
	*The ambiguity introduced by the let construct is avoided by using %prec in the rule defining the let_expr (line 473 & 476 ) 
	example: good.cl line 264 - 266


4. Epilogue:
	This section is used to define the helper functions used by the parser.
	yyerror() function which is called when Bison encounters an error is defined here.
	(line 506 to line 517)




































