README file for Programming Assignment 4 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 ast-lex.cc		-> [cool root]/src/PA4/ast-lex.cc
 ast-parse.cc		-> [cool root]/src/PA4/ast-parse.cc
 bad.cl
 cgen			-> [cool root]/etc/../lib/.i
 cool-tree.cc		-> [cool root]/src/PA4/cool-tree.cc
 cool-tree.h
 cool-tree.handcode.h
 dumptype.cc		-> [cool root]/src/PA4/dumptype.cc
 good.cl
 handle_flags.cc	-> [cool root]/src/PA4/handle_flags.cc
 mycoolc		-> [cool root]/src/PA4/mycoolc
 mysemant		-> [cool root]/src/PA4/mysemant
 semant-phase.cc	-> [cool root]/src/PA4/semant-phase.cc
 semant.cc
 semant.h
 stringtab.cc		-> [cool root]/src/PA4/stringtab.cc
 symtab_example.cc	-> [cool root]/src/PA4/symtab_example.cc
 tree.cc		-> [cool root]/src/PA4/tree.cc
 utilities.cc		-> [cool root]/src/PA4/utilities.cc
 *.d			  dependency files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA4

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code.  Just edit this file.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.  DO
        NOT MODIFY.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.  Note that cool-tree.handcode.h
        differs slightly from the file supplied for PA3.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	cool-tree.cc contains definitions of the provided methods,
	and instantiations of the template for the list handling functions.
	You should not modify this file, but place definitions of all
	methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
	DO NOT MODIFY cool-tree.cc

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	ast-lex.cc and ast-parse.cc implement a lexer and a parser for
	reading text representation of ASTs from console in the format
	produced by the parser phase. DO NOT MODIFY.

	semant-phase.cc contains a test driver for semantic analysis.
	The main program reads an AST in text form from standard input,
	parses it, and then produces a type-annotated AST on standard
	output.  The script mycoolc can pass any of the standard flags
	to the semantic analyzer as well; for this assignment, -s
	(semantic analysis debug) may be useful as it sets a global
	variable semant_debug to true (1).  If you want your semantic
	checker to print debug information when the option is set, write
	your debug code in the following format:

	      if (semant_debug)
	      {
		...
	      }

	semant_debug is provided as a convenience. You don't need to use
	the debugging flags if you don't want to. DON'T MODIFY
	semant-phase.cc

	symtab.h contains a symbol table implementation. Read the
	comments in the file, the "Cool Tour", and look at the example
	in symtab_example.cc.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile the example use of the symbol table, type

	% make symtab_example
        % ./symtab_example

	To compile your semantic analyzer program type:

	% make semant

	To test your semantic checker, type:

        % ./mysemant good.cl

	mysemant is a version of mycoolc that omits code generation.
	mysemant parses all the cool files given on the command line and
	builds a single abstract syntax tree containing all class
	definitions appearing in the input files. Your semantic checker
	is then called on this abstract syntax tree.  If there are no
	errors, the program produces a type-annotated abstract syntax
	tree as output.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

	If you think your semantic checker is correct and behaves like
	the one we wrote, you can try to run mycoolc using your checker,
	your parser and also your lexical analyzer if you choose (see
	below for instructions).  Remember if your lexer, parser or
	checker behaves in an unexpected manner, you may get errors
	anywhere.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA4
----------------

_________________________________

GROUP 04
DEVINDI G.A.I	: E/17/058
LIYANAGE S.N 	: E/17/190	
_________________________________

The semantic analyser is designed to achieve 4 main tasks as follows.

	1. Naming and Scoping
	2. Look at all classes and build an inheritance graph.
	3. Check that the graph is well-formed.
	4. For each class
		(a) Traverse the AST, gathering all visible declarations 
			in a symbol table.
		(b) Check each expression for type correctness.
		(c) Annotate the AST with types.

Mainly, the following files were edited to achieve the above tasks.

	1. semant.cc: main file containing all the implementations
		necessary to achieve the above tasks. The methods used 
		here are declared in cool-tree.handcode.h and semnat.h files.
	
	2. cool-tree.handcode.h: 
		user-defined extensions to the AST nodes used in semant.cc . 
		getters and setters are defined to retrieve data
		specific to all the nodes in the AST.

	3. semnat.h:
		declarations of all the methods and extra variables used
		in semant.cc is defined here. 
			* SymbolTables to store the classes, symbols (attributes), 
			 and methods and associated data 
			* A user-defined data structure to store the details specific
			  to a method, and methods related to it.
			* Declarations of the functions used to declare classes,
			  methods, attributes
			* Declarations of functions used to check type correctness
			  of the nodes
		are declared in this file.

The design decisions and the code structure of the semantic analyser is explained
under the 4 tasks achieved.

======================
1. Naming and Scoping:
======================

	* The symbol table data structure implemented in symtab.h was used to 
	manage naming and scoping.

	* Separate SymbolTables were used to keep track of the classes,attributes
	and methods of the program as shown below (declarations in semant.h).

		1. SymbolTable<Symbol, Class__class> classes_table: 
			Stores the class name and the class object
			(containing parent,features,filename) for all classes in program.

  		2. SymbolTable<Symbol, Entry> symbol_table:
			Stores the attribute name and the declared type for all attributes.

  		3. SymbolTable<Symbol, MethodDeclarations_> method_table:
		  	Stores the method name and the return type, and details of the 
			formal parameters of the method as a MethodDeclaration object
			(The details of the MethodDeclaration type is explained from 
			line 268-281 in this README)
	* These symbol table structures are implemented as a list of lists such that
	the inner list is a scope, and the outer list is a list of scopes.

	* As a result, the children classes, methods and attributes will be inside the
	scopes of parent classes, methods and attributes.

	* The following methods of symbol tables were utilized in semant.cc to modify and
	access the symbol tables.

	    1. 	enterscope: point to a new scope whose parent is the scope 
			it pointed to previously.
		
		2. 	addid(s,i): adda a symbol table entry to the current scope of
			the symbol table mapping symbol `s' to data `d'.
			A new scope is created whose entry list is the new entry
			followed by the old entry list,and whose tail is the old top scope's parent. 
		
		3. 	exitscope: point to the parent scope of the current scope, without
		  	deallocating the child scopes.

		4. 	lookup(s): looks for the symbol `s', starting at the top scope
			and proceeding down the list of scopes until either an
			entry is found whose `get_id()' equals `s', or the end of
			the root scope is reached.  It returns the data item associated 
			with the entry, or NULL if no such entry exists. 
		
		5. 	probe(s):checks the top scope for an entry whose `get_id()'
 	        equals `s', and returns the entry's `get_info()' if
		    found, and NULL otherwise.

	* Using these enterscope, exitscope functions, type correctness was conducted
	  with the methods and attribute definitions applicable to a specific scope.

	* Note on the MethodDeclaration struct declared in semant.h:

		A MethodDeclaration typed Object can be used to store 
		the details of a method such as return type, 
		formal parameter identifiers and types.
		
		The method from_method_class() is used to extract these details and store
		them in the variables return_type, identifiers vector and argument_types vector.

		The methods has_same_args() and matches() are used to check if the formal parameters
		of two methods are similar.

		The method get_undeclared_types() is used to get a vector of all the get_undeclared
		types involved with the method (return type and formal parameter types).
		
======================================================
2. Look at all classes and build an inheritance graph.
======================================================

	* In the first traversal through the AST, all the classes will be
	added to the classes_table SymbolTable variable after checking 
	the following two errors related to class naming.

	(lines 103-137 in semant.cc)
		1. Error 1: SELF_TYPE is an invalid name for a class
		2. Error 2: Classes cannot be redefined
	
	* For each class, if the declaration is correct, move on to checking
	the validity of its parents by going up the inheritance tree until
	the root class (Object) is reached. Two types of errors are handled 
	in regard to the validity of the parents.

	(lines 150-180 in semant.cc)

		1.Error 1: If parent is not in class table-> parent not defined
        2.Error 2: If parent is the class Integer, String, Bool or SELF_TYPE -> invalid parent

	* If classes and their parents are correctly declared, the validity 
	of the inheritance graph is checked.  

=======================================
3. Check that the graph is well-formed.
=======================================

	* The inheritance graph is said to be well formed if it doesn't 
	contain any cycles. This is achieved by checking the existance of cycles
	for each class. 

	* If a cycles are found the errors are logged and semantic checker is
	halted.

	(lines 190-207 in semant.cc)
		1. Error : If the parent of a class X is already in its parents vector
				-> graph contains cycles 
				-> log the error with the class involved in the cycle.

	*If inheritance graph is valid and class definitions are correct
    proceed to traverse the AST for the second time
	to gather details of methods and attributes in every class

=================
4. For each class
=================

(a) Traverse the AST, gathering all visible declarations 
	in a symbol table.
	
	* For each class starting from root, traverse the AST 
    and add the methods and attributes to the symbol tables. 
	(lines 236-237 in semant.cc)

	* This is achieved using three methods:

		1. decl_class():
		================

		* Recursive method to go through the inheritance
		graph starting from root and for each class,
		go through the feature list, extract the attributes 
		and methods separately and store them in separate 
		symbol tables with the aid of methods decl_attr() 
		and decl_method(). (lines 297-362 in semant.cc)

		2. decl_attr():
		================

		* For each attribute of a class, check the validity of the 
		attribute and if attribute is valid, 
		store it in the current scope of the symbol table.
		(lines 381-458 in semant.cc)

		* According to cool manual,
			No attribute name may be defined multiple times in a class, 
			but a method and an attribute may have the same name.

		Therefore, error identified:
		1. Error 1: attribute type is not defined in the program
		2. Error 2: attribute cannot be named as "self"
		3. Error 3: attribute cannot be redefined inside same class
		4. Error 4: an inherited attribute cannot be redefined inside child class

		3. decl_method():
		================

		* For each method in a class, check the validity of the method 
		definition and formal parameters.
		* If method declaration and parameters are valid, store in
		current scope of method table.
		(lines 4911-649 in semant.cc)
		* According to cool manual,
			No method name may be defined multiple times in a class, 
			but a method and an attribute may have the same name.

		Errors identified:
		* Formal parameter errors:

			1. Error 1: formal parameter name cannot be "self"
			2. Error 2: formal parameters cannot be defined multiple 
			times for the same method
		
		* Method declaration errors:
			3: Error 3: cannot have return type or argument 
			type that is not defined in program
			4. Error 4: cannot redefine method in same class

			According to cool manual:
			" To ensure type safety, there are restrictions on the 
			redefinition of inherited methods. The rule is
			simple: If a class C inherits a method f from an 
			ancestor class P, then C may override the inherited
			definition of f provided the number of arguments, 
			the types of the formal parameters, and the return
			type are exactly the same in both definitions "

			5. Error 5: if inherited method is redefined, 
				they cannot have different return types
			6. Error 6: if inherited method is redefined, 
				they cannot have different number of formal parameters
			7. Error 7: if inherited method is redefined, 
				the formal parameters cannot have different types

	
(b) Check each expression for type correctness.

	* After the methods, attributes and classes are stored in
	symbol tables under correct scopes, next is to check the
	type correctness of the expressions.

	* However, before type checking, the correctness of the 
	Main class and main method must be checked, and if they
	are not valid, the semantic analyser must be halted.
	(lines 242-277 in semant.cc)

	* Following errors are detected related to Main class and main method.
		1. Error 1: Main class is not present
		2. Error 2: No 'main' method in class Main.
		3. Error 3: 'main' method in class Main contains arguments.
	
	* If Main class and main method is valid, type checking the classes
	is conducted starting from the root class with the help of the 
	following methods.

		1. type_check_class:
		====================
			* Recursive Method to check the correctness of the 
			types in expressions of all user defined classes
			starting from the root.
			(lines 663-706 in semant.cc)

			* For each class, type correctness of attributes 
			is checked using  type_check_attr() method and 
			type correctness of methods is checked using  
			type_check_method() method.

			* Then move on to the child class and
			  same procedure is repeated.

		2. type_check_attr(): 
		====================

			* Method to check the type correctness of an attribute 
			and its initialization. (lines 719-750 in semant.cc)
			
			* According to the cool manual:
				If initialization is supplied,
				the static type of the expression must conform
				to the declared type of the attribute.

			* Errors handled:
				1. Type inferred by the initialization expression 
				doesn't match with the declared type
		
		3. type_check_method(): 
		=======================

			* Method to check the type correctness of a method.
			( lines 765-815 in semant.cc)
			
			* According to the cool manual:
			The type of the method body must conform to the 
			declared return type

			* Errors handled:
				1. Type inferred by the expressions in the method body
				doesn't conform with the declared return type

		4. type_check_expression:
		=========================

			* Method to check type correctness of the expressions 
			related to a method or an attribute initialization
			
			*For each type of expression, 
			specific type check methods are called 
			and errors are identified for the specific expression type.
			(lines 907-1027 in semant.cc)

		5. type_check_assign():
		=========================

			* Method to check the type correctness of an assignment
			(lines 1044-1091 in semant.cc)
			* According to the cool manual:
				1. The static type of the expression must conform to the declared type of the identifier
				2. It is an error to assign to self
				3. It is an error to assign to an undeclared variable

			* Therefore the errors handled:
				1. Error 1: the name of the assignment identifier is 'self'
				2. Error 2: assigning to an undeclared variable
				3. Error 3: static type of expression not conforming to the declared type 

		6. type_check_static_dispatch:
		==============================

			* Method to check the type correctness of a dispatch in the form 
				<expr>@<dispatch_type>.f(arguments)

			(lines 1111-1172 in semant.cc)
			* The correctness of the types involving the method (f) 
			and the arguments (arguments/actual) is checked 
			by handle_dispatch() helper method.
			
			* According to the cool manual:
				For this form of dispatch, the static type to the left of
				“@”must conform to the type specified to the right of “@”.

			* Therefore, errors handled in this method:
				1. Error 1: dispatch_type class is not defined in the program 
				2. Error 2: the static type to the left of "@" not conforming to the
							type specified to the right of "@"
		
		7. type_check_dispatch:
		=======================

			* Method to check the type correctness of a dispatch in the form 
				<expr>.f(arguments)
						or 
				f(arguments) == self.f(arguments)
			
			(lines 1189-1218 in semant.cc)
			* The correctness of the types involving the method (f) 
			and the arguments/actual is checked 
			by handle_dispatch() helper method.

			* The final type of the dispatch expression is either
				* the type of the return type of the function f
				* type of the expression (if return type of function is SELF_TYPE)

			* Errors related to the method and arguments are 
			 handled in handle_dispatch() method

		8. handle_dispatch():
		=====================

			* Method used to evaluate the method and 
			its arguments in a static or normal dispatch.
			(lines 1242-1338 in semant.cc)

			*According to the cool manual:

				Type checking a dispatch involves several steps.
					* Assume expr has static type A. 
					(expr can have a subclass of A, lets name it as 
					C inferred at runtime)
					* Class A must have a method f,
					the dispatch and the definition of f must have 
					the same number of arguments, 
					and the static type of the ith actual parameter 
					must conform to the 
					declared type of the ith formal parameter
					* If f has return type B and B is a class name, 
					then the static type of the dispatch is B.
					* Otherwise, if f has return type SELF TYPE, 
					then the static type of the dispatch is A.

			* Therefore, the errors detected:
				1. Error 1: method f is not defined under the 
							class of the type of expr
				2. Error 2: method invoked with wrong number 
							of arguments in dispatch
				3. Error 3: ith formal parameter of the method 
							doesn't conform to the declared type
		9. type_union:
		==============
			* Helper function used in type checking conditional 
			and case expressions.
			(lines 1348-1405 in semant.cc)

			* This function is used to find the least upper bound 
				-> least common ancestor for two types 

			* This is done by walking through the inheritance tree 
				of the two types from top to bottom
				and finding the type from which the 
				paths of two types go in separate ways.

		10. type_check_cond:
		====================

			* Method to check the type correctness of a 
			conditional statement (it-then-else)
			(lines 1421-1439 in semant.cc)

			* According to the cool manual:
				*The predicate must have static type Bool. 

				*Let T and F be the static types of the branches of the conditional. 
				Then the static type of the conditional is type_union(T, F) 
				( Walk towards Object from each of T and F until the paths meet.)

			* Therefore, error handled:
				1. Error: Predicate is not type Bool
		
		11. type_check_case:
		====================

			* Method to check the type correctness of a case statement
			(lines 1458-1543 in semant.cc)

			* According to the cool manual:
				* It is an error to bind 'self' in a case
				* Types in case branch must be defined
				* The variables declared on each branch of a case 
					must all have distinct types.
				*  The type of the entire case is the join of the 
					types of its branches.
				(Least upper bound/ least common ancestor of types 
					of all branches)

			Therefore, the errors handled:
				1. Error 1: identifier in case branch is bound to 'self'
				2. Error 2: type in case branch undefined
				3. Error 3: case branches have duplicate types
		
		12. type_check_block:
		=====================

			* Method to check the type correctness of a block in the form
								{ <expr>; ... <expr>; }

			(lines 1556-1565 in semant.cc)

			* According to the cool manual:

				* The expressions are evaluated in left-to-right order
				* The static type of a block is the static type of the 
				last expression

		13. type_check_loop:
		====================

			*Method to check the type correctness of a loop in the form
				
						while <expr> loop <expr> pool
			(lines 1581-1595 in semant.cc)

			*According to the cool manual:   
				* The predicate must have static type Bool. 
				* The body may have any static type. 
				* The static type of a loop expression is Object.

			* Therefore, error handled:
				1. Error: predicate is not of type Bool
		
		14. type_check_new:
		===================

			* Method to check the type correctness of a new expression of the form
									new <type>
			* The static type is <type>.
			(lines 1606-1625 in semant.cc)

			* Error handled : type is undefined

		15. type_check_object:
		======================

			* Method to check whether the type of an 
			object identifier is declared as an attribute

			(lines 1635-1652 in semant.cc)
			* Error: undeclared identifier used
		
		16. type_check_let:
		===================

			* Method to check the type correctness of a let expression of the form,

				let <id1> : <type1> [<- <expr1>],..., <idn> : <typen> [<- <exprn>] in <expr>

			(lines 1684-1739 in semant.cc)

			* According to the cool manual:

				* First <expr1> is evaluated and the result bound to <id1>. 
				* Then <expr2> is evaluated and the result bound to <id2>, 
				and so on, until all of the variables in the let are initialized. 
				(If the initialization of <idk> is omitted, 
				the default initialization of type <typek> is used.) 
				* Next the body of the let is evaluated. 
			

				* The let identifiers <id1>,...,<idn> are visible in 
				the body of the let. 
				* If an identifier is defined multiple times in a let, 
				later bindings hide earlier ones. 
				* Identifiers introduced by let also hide any definitions 
				for the same names in containing scopes. 
				* The type of an initialization expression must conform 
				to the declared type of the identifier. 
				* The type of let is the type of the body.

			* Therefore, errors handled:
				1. Error 1: Identifier type is undefined
				2. Error 2: Idenitifier name is "self"
				3. Error 3: Initialization type of identifier not
				conforming to the declared type

		17. invalid_comparison:
		=======================

			* Helper function to check the validity of expressions 
			involved in the comparison if expressions have basic types.

			(lines 1756-1759 in semant.cc)

			* According to the cool manula:
			If either <expr1> or <expr2> has static type Int, Bool, 
			or String, then the other must have the same static type.

			Therefore, invalid_comparison() function returns
				1. True: if either of the expressions in comparison 
				has a basic type and both doesn't have the same basic type
				2. False: either if the expressions are not basic type and 
				they are not of same type, or both.
		
		18. type_check_eq:
		==================

			* Method to check type correctness of the comparison 
			expression with the aid of function invalid_comparison()

     		(lines 1777-1784 in semant.cc)

			According to cool manual:

			* If either <expr1> or <expr2> has static type Int, Bool, 
			or String, then the other must have the same static type. 
			* Any other types, including SELF TYPE, may be freely compared. 
			* On non-basic objects, equality simply checks for pointer equality 

			Therefore, the error handled :
				1. Error: If either of the expressions is basic 
							but the other doesn't have the same type->
							illegal comparison between basic types.
						
		19. is_descendant: 
		==================

			* Helper function used to check if given two types
				have a descendant-ancestor relationship
			
			(lines 1787-1808 in semant.cc)
		
		20. Three macros containing the type check logics used to
		check the type correctness of arithmetic expressions and
		unary operators.

		   * TYPE_CHECK_ARITH_EXPR_SAME_TYPE() & TYPE_CHECK_ARITH_EXPR(): 
				* Define a token string to type check the arithmetic operations
				* According to the cool manual: 
					For arithmetic expressions,
					the left and right side expressions are first evaluated.
					The static types of the two sub-expressions must be Int.
					The static type of the expression is Int.

				* Error: type(s) of sub-expressions is/are not Int

				(lines 822-870 in semant.cc)

 			* TYPE_CHECK_UNARY(): 
			 	* Define a token string to type check unary operators ~ and not
				* The expression ~<expr>: <expr> must have static type Int
                            and the entire expression has static type Int. 
    			* The expression not <expr>: <expr> must have static type Bool 
                            and the entire expression has static type Bool.

				* Error: expr type for ~ and not are Int and Bool
				(lines 881-898 in semant.cc)

(c) Annotate the AST with types.

 * The final types returned by the expressions are stored in the type
 variable in expression (line 1025 in semant.cc) so that it will be
 displayed in the AST.

* Test files containing all the syntatically incorrect COOL programs
are in the folder "bad"
* Test files containing all the syntatically correct COOL programs
are in the folder "good"
